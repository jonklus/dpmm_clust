---
title: "Non-Conjugate Sampler - Comparing Priors"
author: "Jonathan Klus"
date: "2024-05-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# load necessary functions
# source("./Multivariate_DPMM_nonconj_DEV.R")
# source("./Multivariate_DPMM_nonconj_UVV.R")
# source("./posterior_helper_fxns.R")
# source("./post_processing_inf.R")

# load R libraries
library(ggplot2)
library(mclust)
library(LaplacesDemon)
library(mvtnorm)
library(stringr)
```

## 2D Example - close together

Mixture of 3 multivariate normal densities all with diagonal variance structure
and $\sigma^2 = 10$. The true means are $(0,-5)$, , $(10,2)$, and $(0,10)$, and
$\sum_{j}n_j = 30$.

```{r}
################## simulate data ##############################################

set.seed(516)
nreps = 10
seeds = sample(x = 1:10^4, size = nreps, replace = FALSE)

w = rep(1/3, 3) #c(.35, .25, .4)
means = list(
  #c(10, 10),
  c(0, -5),
  c(0, 10),
  c(10,2)
)

var = diag(5, length(means[[1]])) # variances known, diagonal, and equal

yreps = lapply(X = 1:nreps, 
           FUN = function(x){
             set.seed(seeds[x])
             assign = sample(x = 1:length(means), size = 30, replace = TRUE, prob = w)
             y = lapply(X = assign,
                        FUN = function(x){
                        t(mvtnorm::rmvnorm(n = 1, mean = means[[x]], sigma = var))
                          })
             return(list(y = y, assign = assign))
           })

# # make a grid of plots
pltlist = list()
datalist = list()
for(rep in 1:nreps){

  y_matrix = matrix(data = unlist(yreps[[rep]]$y), ncol = 2, byrow = TRUE)
  assign = yreps[[rep]]$assign

  data = data.frame(
    assign = assign,
    y1 = y_matrix[,1],
    y2 = y_matrix[,2]
  )
  
  datalist[[rep]] = data

  p = ggplot(data = data, aes(x = y1, y = y2)) + #, label = rownames(data))) +
    geom_point(color = assign, size = 0.75) +
    #geom_text(size = 3, hjust = 0, nudge_x = 0.5, color = assign) +
    # geom_text(size = 3, color = assign) +
    theme_classic()

  pltlist[[rep]] = p
}

do.call(grid.arrange, pltlist)#, top = "Simulated 2D Data and True Group Assignments")
# 
# # drop params used to generate data, except for var which is assumed known
# rm(w, means)
```

### Using k means

```{r}
km_plot = list()
ARI = matrix(data = NA, nrow = length(datalist), ncol = 3)
colnames(ARI) = c("K=3", "K=4", "K=5")
for(rep in 1:length(datalist)){
  # fit model
  km_fit3 = kmeans(x = datalist[[rep]][,c("y1", "y2")], centers = 3)
  km_fit4 = kmeans(x = datalist[[rep]][,c("y1", "y2")], centers = 4)
  km_fit5 = kmeans(x = datalist[[rep]][,c("y1", "y2")], centers = 5)
  # calculate adj RAND index
  ARI[rep,] = c(adjustedRandIndex(datalist[[rep]]$assign, km_fit3$cluster),
                adjustedRandIndex(datalist[[rep]]$assign, km_fit4$cluster),
                adjustedRandIndex(datalist[[rep]]$assign, km_fit5$cluster))
  # plot results
  km_plot[[rep]] = ggplot(data = datalist[[rep]][,c("y1", "y2")], aes(x = y1, y = y2)) + #, label = rownames(data))) +
      geom_point(color = km_fit$cluster, size = 0.75) +
      #geom_text(size = 3, hjust = 0, nudge_x = 0.5, color = assign) +
      # geom_text(size = 3, color = assign) +
      theme_classic()
}

# do.call(grid.arrange, km_plot)
print(ARI)
```
### Using MCLUST

```{r}
BIC = mclust::mclustBIC(data = datalist[[1]])
plot(BIC)
mclust_fit = mclust::Mclust(data = datalist[[1]]) #, modelNames = "VVV", G = 2:5)
summary(mclust_fit)
```

