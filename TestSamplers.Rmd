---
title: "Sampler Test Script"
author: "Jonathan Klus"
date: "2024-10-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# load necessary functions
# source("./Samplers/Multivariate_DPMM_unknownvar_DEE.R")
# source("./Samplers/Multivariate_DPMM_unknownvar_DEV.R")
source("./Samplers/Multivariate_DPMM_nonconj_UVV.R")
# source("./Samplers/Multivariate_DPMM_nonconj_DVV.R")
# source("./Samplers/Multivariate_DPMM_nonconj_DEV.R")
# source("./Samplers/Multivariate_DPMM_unknownvar_UVV.R")
source("./Samplers/posterior_helper_fxns.R")
source("./Samplers/post_processing_inf.R")

# load R libraries
library(ggplot2)
library(mclust)
library(LaplacesDemon)
library(mvtnorm)
library(stringr)
library(gridExtra)
library(dplyr)
library(knitr) # kable
# library(kableExtra) # use for complex tables http://haozhu233.github.io/kableExtra/awesome_table_in_pdf.pdf
library(xtable)
```

```{r}
# Well separated simulation setting 

################## simulate data ##############################################

# set.seed(516)
x = 4 # dataset100
seeds = readRDS("./BHsimseeds.rds")
set.seed(seeds[x])

# 
w = rep(1/3,3)
# 
# # negative corr
# means = list(
#    c(-20, 20),
#    c(20, -20),
#    c(0, 0)
#  )

# positive corr
means = list(
    c(-20, -20),
    c(20, 20),
    c(0, 0)
  )

# 5 group 3d

  # w = rep(0.2, 5)
  # 
  # means = list(
  #   c(4, 4, -2),
  #   c(2, 3, 2),
  #   c(3, 2, 5),
  #   c(8, 8, 0),
  #   c(9, 7, 3)
  # )
  # 
  # var = diag(0.25, length(means[[1]]))


  var = diag(10, length(means[[1]])) # variances known, diagonal, and equal


set.seed(seeds[x])
assign = sample(x = 1:length(means), size = 30, replace = TRUE, prob = w)
y = lapply(X = assign,
          FUN = function(x){
          t(mvtnorm::rmvnorm(n = 1, mean = means[[x]], sigma = var))
            })


# drop params used to generate data, except for var which is assumed known
mu_true = means
var_true = var
# yreps # 2nd element is assign
rm(w, means)
```

## dirichletprocess R package

```{r}
# Dirichlet processes can also be used to cluster data based on their common distribution parameters.
y_df = matrix(unlist(y), ncol = 2, byrow = TRUE) %>% as.data.frame() %>% scale()
dpCluster <-  DirichletProcessMvnormal(y_df)
dpCluster <- Fit(dpCluster, 2000, progressBar = TRUE)
plot(dpCluster)
```

## DEE

```{r, include=FALSE, eval=FALSE}
### Fit DEE model
n_iter = 2500
# set hyperparameters
# a = 1; b = 50
# d = 1; f = 1
# g = 1; h = 50
# sigma0 = 200
# lambda0 = diag(x = 25, nrow = length(means[[1]])) # needed for UVV
# nu = length(means[[1]])  # must have nu >= p...Otherwise rinvwish will fail!

# run in fxn
sim_results_DEE = MVN_CRP_sampler_DEE(
        S = n_iter, seed = seeds[x], y = y,
        alpha = 1, r = 1, d = 1, f = 1 , g = 1, h = 20,
        sigma_hyperprior = FALSE, fix_r = FALSE,
        mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 3))),0), ncol = 1),
        a = 1, b = 1,
        k_init = 1, init_method = "kmeans", diag_weights = FALSE, 
        verbose = TRUE, split_merge = FALSE, print_iter = 100, print_start = 0
        )

mod_sum_DEE = dpmm_summary(output = sim_results_DEE, 
       print_k_sum = TRUE, 
       print_phi_sum = TRUE,
       make_traceplot = FALSE,
       burn_in = 500, t_hold = 100, 
       num_dims = 2, equal_var = TRUE,
       calc_perf = FALSE, mu_true = mu_true, 
       var_true = var_true, assign_true = assign)

plot(mod_sum_DEE$var_list_by_k_stephens[[1]]$sigma_1_1, type = "l", 
     xlab = "iter", ylab = "sigma2")
```

## DEV

```{r, include=FALSE, eval=FALSE}
### Fit DEE model
n_iter = 100
# set hyperparameters
# a = 1; b = 50
# d = 1; f = 1
# g = 1; h = 50
# sigma0 = 200
# lambda0 = diag(x = 25, nrow = length(means[[1]])) # needed for UVV
# nu = length(means[[1]])  # must have nu >= p...Otherwise rinvwish will fail!

# run in fxn
sim_results_DEV = MVN_CRP_sampler_DEV(
        S = n_iter, seed = seeds[x], y = y,
        alpha = 1, r = 1, d = 1, f = 1 , g = 1, h = 10,
        sigma_hyperprior = FALSE, fix_r = FALSE,
        mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 2))),0), ncol = 1),
        a = 1, b = 1,
        k_init = 1, init_method = "kmeans", diag_weights = FALSE, 
        verbose = TRUE, split_merge = TRUE, sm_iter = 5, sm_freq = 10, 
        print_iter = 1, print_start = 0
        )

mod_sum_DEV = dpmm_summary(output = sim_results_DEV, 
       print_k_sum = TRUE, 
       print_phi_sum = TRUE,
       make_traceplot = FALSE,
       burn_in = 0, t_hold = 0, 
       num_dims = 2, equal_var = TRUE,
       calc_perf = FALSE, 
       mu_true = mu_true, 
       var_true =  var_true,
       assign_true = assign)

plot(mod_sum$var_list_by_k_stephens[[1]]$sigma_1_1, type = "l", 
     xlab = "iter", ylab = "sigma2")
```

## UVV 

```{r, include=FALSE, eval=FALSE}
### Fit DEE model
n_iter = 1000
# set hyperparameters
# a = 1; b = 50
# d = 1; f = 1
# g = 1; h = 50
# sigma0 = 200
# lambda0 = diag(x = 25, nrow = length(means[[1]])) # needed for UVV
# nu = length(means[[1]])  # must have nu >= p...Otherwise rinvwish will fail!

# run in fxn
sim_results_UVV = MVN_CRP_sampler_UVV(
        S = n_iter, seed = seeds[x], y = y,
        alpha = 1, r = 1, g = 1, h = 25, nu = 3, fix_r = FALSE,
        mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 2))),0), ncol = 1),
        lambda0 = diag(100,2),
        k_init = 1, init_method = "kmeans", diag_weights = FALSE, 
        verbose = TRUE, split_merge = FALSE, print_iter = 1, print_start = 0
        )

mod_sum_UVV = dpmm_summary(output = sim_results_DEV, 
       print_k_sum = TRUE, 
       print_phi_sum = TRUE,
       make_traceplot = FALSE,
       burn_in = 0, t_hold = 0, 
       num_dims = 2, equal_var = TRUE,
       calc_perf = FALSE, mu_true = mu_true, 
       var_true = var_true, assign_true = assign)

plot(mod_sum$var_list_by_k_stephens[[1]]$sigma_1_1, type = "l", 
     xlab = "iter", ylab = "sigma2")
```

## Non-conjugate DEV

```{r, include=FALSE, eval=FALSE}
### Fit DEE model
n_iter = 1000
# set hyperparameters
# a = 1; b = 50
# d = 1; f = 1
# g = 1; h = 50
# sigma0 = 200
# lambda0 = diag(x = 25, nrow = length(means[[1]])) # needed for UVV
# nu = length(means[[1]])  # must have nu >= p...Otherwise rinvwish will fail!

# run in fxn
sim_results_nonconjDEV = MVN_CRP_nonconj_DEV(
        S = n_iter, seed = seeds[x], y = y, 
        alpha = 1, m = 1, a = 1, b = 1, 
        mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 3))),0), ncol = 1),
        sigma0 = 100, 
        k_init = 2, init_method = "kmeans",
        # d = 1, f = 1, 
        sigma_hyperprior = FALSE, standardize_y = FALSE,
        split_merge = TRUE, sm_iter = 5, truth = NA, sm_freq = 10,
        diag_weights = FALSE, verbose = TRUE, print_iter = 10^1, print_start = 0)

sim_results_nonconjDEV$sm_results %>%
  data.frame() %>%
  dplyr::mutate(accept = as.numeric(accept)) %>%
  dplyr::group_by(move_type) %>%
  dplyr::summarize(acc = mean(accept))

S = 200
seed = seeds[x]
y = y
alpha = 1; m = 1
a = 1 
b = 50
mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 2))),0), ncol = 1)
sigma0 = 225
k_init = 1
init_method = "random"
sigma_hyperprior = FALSE
standardize_y = FALSE
split_merge = TRUE
sm_iter = 5
sm_freq = 10
truth = NA
diag_weights = FALSE
verbose = TRUE
print_iter = 1
print_start = 0
  
mod_sum_nonconjDEV = dpmm_summary(output = sim_results_nonconjDEV, 
       print_k_sum = TRUE, 
       print_phi_sum = TRUE,
       make_traceplot = FALSE,
       burn_in = 0, t_hold = 0, 
       num_dims = 2, equal_var = TRUE,
       calc_perf = FALSE, mu_true = mu_true, 
       var_true = var_true, assign_true = assign)

# plot(mod_sum$var_list_by_k_stephens[[1]]$sigma_1_1, type = "l", 
#      xlab = "iter", ylab = "sigma2")

# test n=300 function failure
group_assign = c(rep(1,100), rep(2,100), rep(3,100))

nonconj_phi_prob_DEV(curr_label = 1, group_assign = group_assign, 
                     count_assign = 100, y = y, 
                     mu = matrix(c(-20,20), ncol=1), mu0 = matrix(c(0,0), ncol=1), 
                     Sigma = diag(25,2), Sigma0 = diag(10,2), a = 1, b = 50)
```


## Non-conjugate DVV

```{r, include=FALSE, eval=FALSE}
### Fit DEE model
n_iter = 1000
# set hyperparameters
# a = 1; b = 50
# d = 1; f = 1
# g = 1; h = 50
# sigma0 = 200
# lambda0 = diag(x = 25, nrow = length(means[[1]])) # needed for UVV
# nu = length(means[[1]])  # must have nu >= p...Otherwise rinvwish will fail!

# run in fxn
sim_results_nonconjDVV = MVN_CRP_nonconj_DVV(
        S = n_iter, seed = seeds[x], y = y, 
        alpha = 1, a = 1, b = 10, a0 = 1, b0 = 10,
        mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 3))),0), ncol = 1),
        Sigma0 = diag(10,3), 
        k_init = 1, init_method = "kmeans",
        standardize_y = FALSE,
        split_merge = FALSE, truth = NA,
        diag_weights = FALSE, verbose = TRUE, print_iter = 1, print_start = 0)
  
mod_sum_nonconjDVV = dpmm_summary(output = sim_results_nonconjDVV, 
       print_k_sum = TRUE, 
       print_phi_sum = TRUE,
       make_traceplot = FALSE,
       burn_in = 0, t_hold = 0, 
       num_dims = 2, equal_var = FALSE,
       calc_perf = FALSE, mu_true = mu_true, 
       var_true = var_true, assign_true = assign)

# plot(mod_sum$var_list_by_k_stephens[[1]]$sigma_1_1, type = "l", 
#      xlab = "iter", ylab = "sigma2")

# test n=300 function failure
group_assign = c(rep(1,100), rep(2,100), rep(3,100))

nonconj_phi_prob_DEV(curr_label = 1, group_assign = group_assign, 
                     count_assign = 100, y = y, 
                     mu = matrix(c(-20,20), ncol=1), mu0 = matrix(c(0,0), ncol=1), 
                     Sigma = diag(25,2), Sigma0 = diag(10,2), a = 1, b = 50)
```

## Non-conjugate UVV

```{r, include=FALSE, eval=FALSE}

n_iter = 500
# set hyperparameters
# a = 1; b = 50
# d = 1; f = 1
# g = 1; h = 50
# sigma0 = 200
# lambda0 = diag(x = 25, nrow = length(means[[1]])) # needed for UVV
# nu = length(means[[1]])  # must have nu >= p...Otherwise rinvwish will fail!

# run in fxn
sim_results_nonconjUVV = MVN_CRP_nonconj_UVV(
        S = n_iter, seed = seeds[x], y = y, 
        alpha = 1, Sigma0 = diag(100,3), 
        mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 3))),0), ncol = 1),
        k_init = 1, init_method = "kmeans",
        nu = 5, Lambda0 = diag(1,3),
        standardize_y = FALSE,
        split_merge = TRUE, sm_iter = 5, sm_freq = 10, truth = NA,
        diag_weights = FALSE, verbose = TRUE, print_iter = 10, print_start = 0)

sim_results_nonconjUVV$sm_results %>%
  data.frame() %>%
  dplyr::mutate(accept = as.numeric(accept)) %>%
  dplyr::group_by(move_type) %>%
  dplyr::summarize(acc = mean(accept))
  
mod_sum_nonconjUVV = dpmm_summary(output = sim_results_nonconjUVV, 
       print_k_sum = TRUE, 
       print_phi_sum = TRUE,
       make_traceplot = FALSE,
       burn_in = 500, t_hold = 100, 
       num_dims = 3, equal_var = FALSE, off_diag = TRUE,
       calc_perf = TRUE, mu_true = mu_true, 
       var_true = lapply(X = 1:length(mu_true), FUN = function(x){var_true}), 
       assign_true = assign)

# plot(mod_sum$var_list_by_k_stephens[[1]]$sigma_1_1, type = "l", 
#      xlab = "iter", ylab = "sigma2")

S = 500; seed = seeds[x]; y = y
alpha = 1; m =1; Sigma0 = diag(100,3)
mu0 = matrix(round((colMeans(matrix(unlist(y), ncol = 3))),0), ncol = 1)
k_init = 1; init_method = "kmeans"
nu = 5; Lambda0 = diag(1,3)
standardize_y = FALSE
split_merge = TRUE; sm_iter = 5; sm_freq = 10; truth = NA
diag_weights = FALSE; verbose = TRUE; print_iter = 10; print_start = 0
```