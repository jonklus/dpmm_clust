---
title: "Non-Conjugate Sampler - No SM Testing"
author: "Jonathan Klus"
date: "2024-04-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# load necessary functions
source("./Multivariate_DPMM_nonconj_DEV.R")
# source("./Multivariate_DPMM_nonconj_UVV.R")
# source("./Multivariate_DPMM_nonconj_DEV.R")
source("./posterior_helper_fxns.R")
source("./post_processing_inf.R")

# load R libraries
library(ggplot2)
library(label.switching)
library(LaplacesDemon)
library(mvtnorm)
library(stringr)
```

## Sampler Examples

### 2D Example - well separated

Mixture of 3 multivariate normal densities all with diagonal variance structure
and $\sigma^2 = 10$. The true means are $(-20,20)$, $(20,-20)$, and $(0,0)$, and
$\sum_{j}n_j = 30$.

```{r}
################## simulate data ##############################################

set.seed(516)
nreps = 10
seeds = sample(x = 1:10^4, size = nreps, replace = FALSE)

w = c(0.4, 0.3, 0.3)
means = list(
  c(-20, 20),
  c(20, -20),
  c(0, 0)
)

var = diag(10, length(means[[1]])) # variances known, diagonal, and equal

yreps = lapply(X = 1:nreps, 
           FUN = function(x){
             set.seed(seeds[x])
             assign = sample(x = 1:length(means), size = 30, replace = TRUE, prob = w)
             y = lapply(X = assign,
                        FUN = function(x){
                        t(mvtnorm::rmvnorm(n = 1, mean = means[[x]], sigma = var))
                          })
             return(list(y = y, assign = assign))
           })

# make a grid of plots
# pltlist = list()
# for(rep in 1:nreps){
# 
#   y_matrix = matrix(data = unlist(yreps[[rep]]$y), ncol = 2, byrow = TRUE)
#   assign = yreps[[rep]]$assign
# 
#   data = data.frame(
#     assign = assign,
#     y1 = y_matrix[,1],
#     y2 = y_matrix[,2]
#   )
# 
#   p = ggplot(data = data, aes(x = y1, y = y2)) + #, label = rownames(data))) +
#     geom_point(color = assign, size = 0.75) +
#     #geom_text(size = 3, hjust = 0, nudge_x = 0.5, color = assign) +
#     # geom_text(size = 3, color = assign) +
#     theme_classic()
# 
#   pltlist[[rep]] = p
# }
# 
# do.call(grid.arrange, pltlist)#, top = "Simulated 2D Data and True Group Assignments")
# 
# # drop params used to generate data, except for var which is assumed known
# rm(w, means)
```

#### DEV sampler 

#### testing non-conj SM

```{r}
x = 5 # first simulated data set 
n_iter = 14
y_matrix = matrix(data = unlist(yreps[[x]]$y), ncol = 2, byrow = TRUE)
S = n_iter
seed = seeds[x]
y = yreps[[x]]$y
alpha = 1
mu0 = matrix(round((colMeans(matrix(unlist(yreps[[x]]$y), ncol = 2))),0), ncol = 1)
sigma0 = 50
a = 1
b = 50
sigma_hyperprior = FALSE
k_init = 1
diag_weights = FALSE
verbose = TRUE
print_iter = 1
split_merge = TRUE
sm_iter = 5
truth = list(mu_true = means, var_true = var, assign_true = yreps[[x]]$assign)
standardize_y = FALSE
```


##### without split-merge step

```{r}
x = 5 # first simulated data set 
n_iter = 1000
y_matrix = matrix(data = unlist(yreps[[x]]$y), ncol = 2, byrow = TRUE)
output = MVN_CRP_nonconj_DEV(
        S = n_iter, seed = seeds[x], y = yreps[[x]]$y, alpha = 1, 
        mu0 = matrix(round((colMeans(matrix(unlist(yreps[[x]]$y), ncol = 2))),0), ncol = 1),
        sigma0 = 500,
        a = 1, b = 500, sigma_hyperprior = FALSE,
        k_init = 1, diag_weights = FALSE,
        verbose = TRUE, print_iter = 1000, split_merge = FALSE,
        truth = list(mu_true = means, var_true = var, assign_true = yreps[[x]]$assign), 
        )

# summarize model
mod_sum = dpmm_summary(output = output,
               print_phi_sum = TRUE,
               print_k_sum = TRUE,
               make_traceplot = FALSE,
               burn_in = 0, t_hold = 200,
               num_dims = 2,
               calc_perf = TRUE,
               mu_true = output$truth$mu_true,
               var_true = lapply(X = 1:length(output$truth$mu_true),
                                 FUN = function(x){output$truth$var_true}),
               assign_true = output$truth$assign_true,
               equal_var = FALSE, off_diag = FALSE)

# testing k=1 issue
# drop_me = which(output$k == 2)

prob_list_by_k = get_probs_by_k(probs = output$group_probs, 
                                n_groups = output$k, 
                                burn_in = 0, 
                                iter_threshold = 200)

group_assign_list_by_k = get_assign_by_k(assign = output$group_assign, 
                                         n_groups = output$k, 
                                         burn_in = 0, 
                                         iter_threshold = 200)

mean_list_by_k = list_params_by_k(draws = output$means, 
                                          iter_list = prob_list_by_k$iter_list,
                                          k_vec = output$k,
                                          relabel = FALSE, 
                                          permutation = stephens_result,
                                  param_type = "Mean")

var_list_by_k = list_params_by_k(draws = output$vars, 
                                          iter_list = prob_list_by_k$iter_list,
                                          k_vec = output$k,
                                          relabel = FALSE, equal_var = FALSE,
                                          param_type = "Var")

# stephens_result = get_stephens_result(group_assign_list_by_k = group_assign_list_by_k, 
#                                         prob_list_by_k = prob_list_by_k$prob_list)

kl_res = calc_KL_diverg(y = output$data,
                        mu_est = mean_list_by_k,
                        Sigma_est = var_list_by_k,
                        group_assign = group_assign_list_by_k,
                        true_assign = output$truth$assign_true,
                        mu_true = output$truth$mu_true,
                        Sigma_true = lapply(X = 1:length(output$truth$mu_true),
                                 FUN = function(x){output$truth$var_true}),
                        equal_var_assump = FALSE,
                        off_diag = FALSE)
               
mod_sum = dpmm_summary(output = output,
               print_phi_sum = TRUE,
               print_k_sum = TRUE,
               make_traceplot = FALSE,
               burn_in = 0, t_hold = 100,
               num_dims = 2,
               calc_perf = TRUE,
               mu_true = output$truth$mu_true,
               var_true = lapply(X = 1:length(output$truth$mu_true),
                                 FUN = function(x){output$truth$var_true}),
               assign_true = output$truth$assign_true,
               equal_var = FALSE, off_diag = FALSE)

# sim_results_DEV_no_sm = parallel::mclapply(X = 1:10, mc.cores = 10,
#       FUN = function(x){
#         
#         print(x)
#         
#         # fit model
#         output = MVN_CRP_nonconj_DEV(
#           S = n_iter, seed = seeds[x], y = yreps[[x]]$y, alpha = 1, 
#           mu0 = matrix(round((colMeans(matrix(unlist(yreps[[x]]$y), ncol = 2))),0), ncol = 1),
#           sigma0 = 100,
#           a = 1, b = 10, sigma_hyperprior = FALSE,
#           k_init = 1, diag_weights = FALSE,
#           truth = list(mu_true = means, var_true = var, assign_true = yreps[[x]]$assign),
#           verbose = FALSE, split_merge = FALSE)
#         
#         # summarize model
#         mod_sum = dpmm_summary(output = output,
#                        print_phi_sum = TRUE,
#                        print_k_sum = TRUE,
#                        make_traceplot = FALSE,
#                        burn_in = 2000, t_hold = 250,
#                        num_dims = 2,
#                        calc_perf = TRUE,
#                        mu_true = output$truth$mu_true,
#                        var_true = lapply(X = 1:length(output$truth$mu_true),
#                                          FUN = function(x){output$truth$var_true}),
#                        assign_true = output$truth$assign_true,
#                        equal_var = FALSE)
#         
#         return(mod_sum)
#         
#         })

```

```{r}
n_iter=12000
x=3
# remember that all functions now default to centering & scaling y
output = MVN_CRP_nonconj_UVV(
  S = n_iter, seed = seeds[x], y = yreps[[x]]$y, alpha = 1,
  mu0 = matrix(c(0,0), ncol = 1),
  # mu0 = matrix(round((colMeans(matrix(unlist(yreps[[x]]$y), ncol = 2))),0), ncol = 1),
  Sigma0 = (diag(1.2, 2) - 0.20), 
  Lambda0 = diag(1,2), nu = 5,
  k_init = 1, diag_weights = FALSE, 
  truth = list(mu_true = means, var_true = var, assign_true = yreps[[x]]$assign), 
  verbose = TRUE, print_iter = 1000, split_merge = FALSE)

# summarize model
mod_sum = dpmm_summary(output = output,
               print_phi_sum = TRUE,
               print_k_sum = TRUE,
               make_traceplot = FALSE,
               burn_in = 2000, t_hold = 250,
               num_dims = 2,
               calc_perf = TRUE,
               mu_true = output$truth$mu_true,
               var_true = lapply(X = 1:length(output$truth$mu_true),
                                 FUN = function(x){output$truth$var_true}),
               assign_true = output$truth$assign_true,
               equal_var = FALSE)
        
# sim_results_UVV_no_sm = parallel::mclapply(X = 1:10, mc.cores = 10,
#       FUN = function(x){
#         
#         print(x)
#         
#         # fit model
#         output = MVN_CRP_nonconj_UVV(
#           S = n_iter, seed = seeds[x], y = yreps[[x]]$y, alpha = 1,
#           mu0 = matrix(round((colMeans(matrix(unlist(yreps[[x]]$y), ncol = 2))),0), ncol = 1),
#           Sigma0 = diag(50, 2), Lambda0 = diag(10,2), nu = 5,
#           k_init = 1, diag_weights = FALSE, 
#           truth = list(mu_true = means, var_true = var, assign_true = yreps[[x]]$assign), 
#           verbose = FALSE, split_merge = FALSE)
#         
#         # summarize model
#         mod_sum = dpmm_summary(output = output,
#                        print_phi_sum = TRUE,
#                        print_k_sum = TRUE,
#                        make_traceplot = FALSE,
#                        burn_in = 2000, t_hold = 250,
#                        num_dims = 2,
#                        calc_perf = TRUE,
#                        mu_true = output$truth$mu_true,
#                        var_true = lapply(X = 1:length(output$truth$mu_true),
#                                          FUN = function(x){output$truth$var_true}),
#                        assign_true = output$truth$assign_true,
#                        equal_var = FALSE)
#         
#         return(mod_sum)
#         
#         })

```

## 2D Example - close together

Mixture of 3 multivariate normal densities all with diagonal variance structure
and $\sigma^2 = 10$. The true means are $(10,10)$, $(0,-5)$, , $(12,-2)$, and $(0,10)$, and
$\sum_{j}n_j = 50$.

```{r, echo=FALSE}
################## simulate data ##############################################
w = c(.35, .25, .4)
means = list(
  #c(10, 10),
  c(0, -5),
  c(0, 10),
  c(12,2)
)

var = diag(9, length(means[[1]])) # variances known, diagonal, and equal

yreps = lapply(X = 1:nreps, 
           FUN = function(x){
             set.seed(seeds[x])
             assign = sample(x = 1:length(means), size = 30, replace = TRUE, prob = w)
             y = lapply(X = assign,
                        FUN = function(x){
                        t(mvtnorm::rmvnorm(n = 1, mean = means[[x]], sigma = var))
                          })
             return(list(y = y, assign = assign))
           })

# # make a grid of plots
# pltlist = list()
# for(rep in 1:nreps){
# 
#   y_matrix = matrix(data = unlist(yreps[[rep]]$y), ncol = 2, byrow = TRUE)
#   assign = yreps[[rep]]$assign
# 
#   data = data.frame(
#     assign = assign,
#     y1 = y_matrix[,1],
#     y2 = y_matrix[,2]
#   )
# 
#   p = ggplot(data = data, aes(x = y1, y = y2)) + #, label = rownames(data))) +
#     geom_point(color = assign, size = 0.75) +
#     #geom_text(size = 3, hjust = 0, nudge_x = 0.5, color = assign) +
#     # geom_text(size = 3, color = assign) +
#     theme_classic()
# 
#   pltlist[[rep]] = p
# }
# 
# do.call(grid.arrange, pltlist)#, top = "Simulated 2D Data and True Group Assignments")
# 
# # drop params used to generate data, except for var which is assumed known
# rm(w, means)
```

#### DEV sampler 

##### without split-merge step

```{r, eval=FALSE}
x = 5 # first simulated data set 
n_iter = 12000
y_matrix = matrix(data = unlist(yreps[[x]]$y), ncol = 2, byrow = TRUE)
mod_test2 = MVN_CRP_nonconj_DEV(
        S = n_iter, seed = seeds[x], y = yreps[[x]]$y, alpha = 1, 
        mu0 = matrix(round((colMeans(matrix(unlist(yreps[[x]]$y), ncol = 2))),0), ncol = 1),
        sigma0 = 25,
        a = 1, b = 10, sigma_hyperprior = FALSE,
        k_init = 1, diag_weights = FALSE,
        verbose = TRUE, print_iter = 1000, split_merge = FALSE
        )


table(mod_test2$k)
```

